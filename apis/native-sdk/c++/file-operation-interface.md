# File Operation Interface

The EDFS-SDK library provides digital file encryption, decryption and sharing function interfaces.

In the EDFS-SDK library, file encryption includes actively changing a file from an unencrypted state to a secure encrypted state by calling the file task operation interface. And the EDFS-SDK real-time file system kernel encrypts a file through sensorless encryption according to the configured rules.

Correspondingly, file decryption includes externally calling the file task operation interface to actively decrypt an encrypted file into an unencrypted plaintext state, as well as EDFS-SDK real-time file system kernel driver and EDFS LocalServer module to decrypt file data in memory without feeling, Provide data to applications in real time.

The file operation task module only contains external modules, or the user actively operates to encrypt, decrypt, or distribute a file. It does not include the senseless encryption and decryption provided by the EDFS-SDK real-time file system kernel driver and the EDFS LocalServer module.

The file operation task module operates the user-specified file through asynchronous multi-threading, and in order to ensure the security of the file data in the file recoding operation stage during the file encryption and decryption process, the file operation task module operates the user-specified file through the copy operation mode uniformly. In the file data re-encoding stage, all modifications to the file data are performed in the externally specified file. After the operation is completed, the external decides whether to delete the source file or backup the source file. This is a disaster tolerance mechanism generated by EDFS-SDK to prevent problems caused by sudden power failure or program abnormalities that may occur during the encoding process.

EDFS-SDK provides file manual operation functions, including file encryption, decryption, sharing and other operations, and provides task operation interfaces to support external control of file operation tasks, including task cancellation and other operations.

The encryption operation is only completed using the public key of the default identity currently specified by the user. The external should confirm that the user login has been completed before calling the file operation interface, and the operation of setting the user identity and default identity The decryption operation is only completed using all the private keys owned by the current user. The external should confirm that the user login and the operation of setting the user's identity have been completed before calling the file operation interface. The identities and actions (adding or removing identities) used by the distribution operation are externally added according to the objects of a distribution operation

The file operation interface uses the task mechanism. An external file operation task should be created first, and various parameters of the file operation task (including basic parameters and extended parameters) should be set. The file operation is a time-consuming operation. The library uses a new thread to complete it asynchronously. During the execution of the file operation, the outside can control the execution of the file operation through the task mechanism interface. The intermediate status information and final result information of the file operation should be obtained by polling through the task operation interface, and the corresponding interface prompt information should be displayed. The standard flow of file manipulation tasks is as follows:

1. Initialize a file operation task: set the basic parameter attributes of a file operation task, including the number of threads corresponding to the task, and the action of the task (encryption/decryption/distribution)
2. Set the task target of a file operation: set the task target (file/folder) corresponding to a file operation one by one into the EDFS-SDK library through the interface
3. Set the identity operation action of a file distribution operation: only for the file distribution operation, the interface call will take effect, and the identity addition and deletion operation will be performed on the identity area of the file.
4. Set the signature attribute of a file distribution operation: only for the file distribution operation, the interface call will take effect
5. Start the file operation task;
6. Get file operation task status:
7. Control the file operation task (including the suspension of the file operation task, etc.), because the file operation task is an asynchronous multi-threaded task, so the control of a file operation task will not be reflected immediately, and the final result should be obtained by obtaining the file operation. Get task status interface
8. Get the file operation task result report
9. Reversely initialize a file operation task and destroy various objects created in a file operation task.

### Initialize File Operation

Initialize a file operation task.

```c
INT32 TSK_FileOpTask_Init(INT32 nAction,INT32 nThreadCount);
```

<details>

<summary>Parameters</summary>

* INT32
  * nAction - the specific operation corresponding to this file operation task \[IN]
    * 1 encryption&#x20;
    * 2 decryption&#x20;
    * 3 distribution
* INT32
  * nThreadCount - the number of threads to be started for this file operation task, the default value is 1 \[IN]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * Less than 0 indicates that the initialization of the file operation task failed, and no subsequent operations are required. Greater than or equal to 0 indicates that the initialization was successful, and the **task ID** corresponding to the file operation task is returned. All subsequent operations and control of the file operation task are performed through the task ID.

</details>

{% hint style="info" %}
nThreadCount, manual file operation is a time-consuming and computationally intensive operation. It is recommended to achieve a balance between performance and user experience by setting a reasonable number of multi-threads, such as the maximum number of threads set to (number of cpu cores/2+1)

The internal library will use the file as the unit, and the internal library will start the task thread number threshold that does not exceed the externally set threshold for multi-threaded processing of multiple files in one task. Of course, if the number of target files of a file operation task is less than the set number of threads, the Turn on multithreading with the actual number of files
{% endhint %}

### Add a File to an Operation

Add a full path of the file/folder to be operated to the specified file operation task.

```c
INT32 TSK_FileOpTask_PushAFileToTask(INT32 nTaskID, WCHAR* pSrcFullPath, WCHAR* pDstFullPath);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID\[IN]
* WCHAR \*
  * pSrcFullPath-  the full path information of the source file/folder to be operated \[IN]
* WCHAR \*
  * pDstFullPath - the full path information of the target file/folder to be operated \[IN]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success success

</details>

{% hint style="info" %}
pSrcFullPath, pDstFullPath use OS native way to process string type data, in windows operating system, use Unicode character set, in Linux, Mac, IOS, Android and other operating systems, use UTF-8 character set.

One file operation task can be operated to process multiple files/folders at the same time, and the external can call this function multiple times during one file operation task to set the target full path of one file operation task

​This function is only valid before the task is actually started. After the task state has been started, including the task is in the suspended state, the interface cannot be called again to complete the addition of the operation target.

​Only the encryption and decryption operations need to pass in two paths. In most cases, distribution operations are performed on the source file because the reserved header space is sufficient. Therefore, the distribution operation only needs to pass in the source file path, and the target file can be passed NULL, The source file and the target file must not be the same path, and the source file must exist.
{% endhint %}

### Add Identity to a File Operation

Add a pending identity item action to the specified file operation task.

```c
INT32 TSK_FileOpTask_PushAAction(INT32 nTaskID, BOOLEAN bDelAdd, BYTE* IID, PermissionInfo nPermission, int nLastTime, BYTE* pKeyBuf, DWORD nKeyBufLen);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID\[IN]
* BOOLEAN
  * bDelAdd - add or delete an identity in the identity area, true, add, false, delete \[IN]IID, the 20-byte identity ID information of the identity to be operated \[IN]
* CHAR \*
  * IID - identity ID \[IN]
* PermissionInfo
  * nPermission - the permission information of the identity to be operated, when deleting the identity action, this parameter is meaningless, you can pass an empty permission \[IN]
* INT
  * nLastTime - the last use time limit information of the identity to be operated, when deleting the identity action, this parameter is meaningless, you can pass 0 \[IN]
* CHAR \*
  * pKeyBuf - the public key information of the identity to be operated, when deleting the identity action, this parameter is meaningless, you can pass NULL \[IN]
* DWORD
  * nKeyBufLen - the public key length information of the identity to be operated, when deleting the identity action, this parameter is meaningless, you can pass 0 \[IN]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success, success;
  * Others are failures, please refer to the standard return value definition of the EDFS Native SDK library

</details>

{% hint style="info" %}
This interface is only valid for file distribution. The identity area adjustment of the TSK library uses the action restoration method to perform the addition or deletion of identities.

The user's distribution actions to the specified files or folders should be recorded externally, and sent to the TSK library as an action list one by one, and the library will restore the actions in the order of the user's distribution actions, and finally complete the distribution operation.

This function is only valid before the task is actually started. After the task state has been started, including the task is in the suspended state, the interface cannot be called again to complete the addition of the operation target.
{% endhint %}

### Set a Signature Action for File Operation Task

Set a file operation task signature action.

```c
INT32 TSK_FileOpTask_SetShareSign(INT32 nTaskID, BYTE nSignAction);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID \[IN]
* CHAR
  * nSignAction - the signature action information \[IN]
    * 0 is to keep the signature information
    * 1 is to set the signature information
    * 2 is to clear the signature information

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success success
  * Others are failures, please refer to the standard return value definition of the EDFS Native SDK library

</details>

{% hint style="info" %}
Set the signature action only for file distribution operations. The default value in the library is 0, and the current signature information is maintained.

This function is only valid before the task is actually started. After the task state has been started, including the task is in the suspended state, the interface cannot be called again to complete the addition of the operation target.
{% endhint %}

### Start a File Operation

Start a file operation task.

```c
INT32 TSK_FileOpTask_StartATask(INT32 nTaskID);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID \[IN]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success success
  * Others are failures, please refer to the standard return value definition of the EDFS Native SDK library

</details>

{% hint style="info" %}
After the file operation task starts, you cannot call the setting parameter interface again, modify the properties of the file operation task, and perform asynchronous operations. Asynchronous multi-threading will be started internally to complete the real transaction.
{% endhint %}

### Abort a File Operation Task

```c
INT32 TSK_FileOpTask_CancelATask(INT32 nTaskID);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID \[IN]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success success
  * Others are failures, please refer to the standard return value definition of the EDFS Native SDK library

</details>

{% hint style="info" %}
The file operation task is an asynchronous multi-threaded operation. The return value of the interface call to abort a task is simply to return whether the interface call is successful. The cancellation status of the task is ultimately based on the result of the file operation task status interface call.

​After the file operation task is canceled, it cannot be opened again. The external interface should also call the delete file operation task interface to release various system resources occupied by the file operation task.

If the file operation task is canceled, the file status of the completed operation will not be rolled back. Externally, the Get File Operation Task Result Report API can be called to obtain the operation result of the file operation task.
{% endhint %}

### Delete a File Operation Task

```c
INT32 TSK_FileOpTask_UnInitATask(INT32 nTaskID);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID \[IN]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success success
  * Others are failures, please refer to the standard return value definition of the EDFS Native SDK library

</details>

{% hint style="info" %}
After a file operation task is completed (including active cancellation), the external should call this interface to release various system resources occupied by the file operation task

The task status is estimated and in progress. It is not allowed to delete. It needs to wait for completion, or actively cancel the task before it can be deleted.
{% endhint %}

### Get Status of a File Operation Task

Initialize the EDFS-SDK Native library.

```c
INT32 TSK_FileOpTask_GetATaskState(INT32 nTaskID,INT32* nState,INT64* nTotalLength,INT64* nCurrentLength);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID\[IN]
* INT32 \*
  * nState - the current state of the specified file operation task \[OUT]
* INT64 \*
  * nTotalLength - specifies the total length of data to be processed (in bytes) for file operation tasks \[OUT]
* INT64 \*
  * nCurrentLength - specifies the currently processed data length (in bytes) of the file operation task \[out]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success success
  * Others are failures, please refer to the standard return value definition of the EDFS Native SDK library

</details>

{% hint style="info" %}
In the EDFS-SDK library, the file operation task status is defined as follows:

* 0--to be started, nTotalLength, nCurrentLength data is invalid
* 1--Data processing is in progress (estimating data length stage), nTotalLength, nCurrentLength data are invalid, and the external interface prompt can simply indicate that the time is being estimated
* 2--Data processing is in progress (data processing stage), external can use nTotalLength, nCurrentLength to convert percentage, or directly display data length
* 3--Data processing is completed (all data processing is successful), nTotalLength, nCurrentLength data is invalid
* 4--Data processing is completed (external active cancellation), nTotalLength, nCurrentLength data is invalid

If the task status is successful, it does not mean that the file is processed successfully. The file processing result needs to be obtained by calling the Get File Operation Task Result Report.

The file operation task is an asynchronous multi-threaded task. The external can periodically obtain the task status through the operation task ID through a worker thread polling method. To avoid frequent refresh of the interface, it is recommended not to set the timing too short, and it is recommended to obtain it at a time of 500ms.

There is an abnormal situation to be processed outside the conversion percentage. The length of the total data to be obtained is 0, and the length of the processed data is also 0 for a long time. For example, a large number of empty files are encrypted.
{% endhint %}

### Get Results of File Operation Task

Get a file operation task report of final result.

```c
INT32 TSK_FileOpTask_GetATaskReport(INT32 nTaskID, INT32 nReportMode, BYTE* pReportBuf, INT32* nReportBufLength);
```

<details>

<summary>Parameters</summary>

* INT32
  * nTaskID - the specified file operation task ID\[IN]
* INT32
  * nReportMode - result report mode \[IN]
* CHAR \*
  * pReportBuf - the buffer area of the externally prepared reception result report \[IN/OUT]
* INT32 \*
  * nReportBufLength - the buffer length of the externally prepared reception result report \[IN/OUT]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * KError\_Success success
  * Others are failures, please refer to the standard return value definition of the EDFS Native SDK library

</details>

{% hint style="info" %}
The result report is returned as a memory stream (each element is placed in the externally provided memory buffer in the form of direct memory copy)

An example of a minimalist mode report is as follows: 4-byte integer count+4-byte integer success+4-byte integer fail+4-byte integer ignore

An example of a full mode report is as follows: 4-byte integer count + 4-byte integer success + 4-byte integer fail + 4-byte integer ignore + file operation results one by one

The result of a single file operation is packaged into a stream and the structure is as follows 4 bytes nAction + 4 bytes nResult + 4 bytes source file full path length (including trailing 0 length) + source file full path (including trailing 0) + 4 bytes target file full path length (including trailing 0) + The full path of the target file (including the trailing 0), the full path of the target file may be empty, then the length is parsed as 0, and the next field can be read directly according to the offset

Externally, you can first parse out the total number of file elements in count, and cyclically parse the file operation result through the memory offset.
{% endhint %}

```c
//The result of a single file operation is defined as follows:

//The file operation is successful
#define FILEOP_RESULT_NOERROR 0 
//The file operation is ignored. For example, when encrypting a file, it is an encrypted file. 
//When decrypting a file, it is a non-encrypted file. The target file of the distribution file is not encrypted.
#define FILEOP_RESULT_IGNORE -1 
//The file operation failed because the file could not be served, 
//such as file open failure or read and write failure, and the final file post-processing failure.
#define FILEOP_RESULT_FILECANTSERVER -2 
//The file operation failed because the TSK library returned a failure, such as failure to create a TEFS structure
#define FILEOP_RESULT_TSKFAILED -3 
//The file operation failed because of permission issues, 
//such as the source file does not allow decryption or distribution is not allowed
#define FILEOP_RESULT_PERMISSIONFAILED -4 
//Encrypted files, but the version does not support, reject
#define FILEOP_RESULT_VERSIONFAILED -5 
//Encrypt the file, but the key area check error, reject
#define FILEOP_RESULT_DATAFAILED -6 
```

### Check if Task Module can be Exited

Check whether the file operation task module can exit.

```c
INT32 TSK_FileOpTask_CanExit();
```

<details>

<summary>Parameters</summary>

none

</details>

<details>

<summary>Return Values</summary>

* INT32
  * 0 means that there is currently a task being executed and cannot be exited, 1 means that all the current tasks are executed and the program can be exited.

</details>

{% hint style="info" %}
It is recommended that external users call this interface when the application exits or the user logs out to check whether there are still file operation tasks in progress.
{% endhint %}

### Adjust by Flow

Adjust the specified encrypted header stream data through the given identity and related attributes, and return the new encrypted header stream data to the outside.

```c
INT32 TSK_FileOp_AdjustByFlow(BYTE* pHeadSrc, INT32 nHeadFlowSrcLen, BYTE* pHeadFlowDst, INT32* nHeadFlowDstLen,BOOLEAN bDelAdd, BYTE* nIID, PermissionInfo nPermission, int nLastTime, BYTE* pKeyBuf, DWORD nKeyBufLen);
```

<details>

<summary>Parameters</summary>

* CHAR \*
  * pHeadFlowSrc - external incoming raw encrypted header flow data \[IN]
* INT32
  * nHeadFlowSrcLen - the length information of the original encrypted header flow data incoming from the outside \[IN]
* CHAR \*
  * pHeadFlowDst - externally prepared to receive the adjusted encrypted header flow data buffer \[IN/OUT]
* CHAR \*
  * nHeadFlowDstLen - the adjusted length of encrypted header flow data \[IN/OUT]
* BOOLEAN
  * bDelAdd - whether to add or delete the envelope to the encrypted header identity area, true to add, false to delete \[IN]
* CHAR \*
  * nIID - the identity ID to be modified \[IN]
* PermissionInfo
  * nPermission - the permission corresponding to the identity to be modified \[IN]
* INT
  * nLastTime - the last file usage time of the identity to be modified \[IN]
* CHAR \*
  * pKeyBuf - the key buffer of the identity to be modified \[IN]
* DWARD
  * nKeyBufLen - the key buffer length of the identity to be modified \[IN]

</details>

<details>

<summary>Return Values</summary>

* INT32
  * Return the result of the operation, refer to the definition of the return result of the TSK library

</details>

{% hint style="info" %}
The buffer area prepared externally for receiving new encrypted header stream data must be large enough. A new identity in the encrypted header envelope area occupies 154 bytes in the current version. It is recommended that the buffer area prepared externally be 1024 bytes larger than the original envelope. The actual adjusted header data length will be returned by nHeadFlowDstLen

The special interface is generally called during the development of APPs that have proxy file sharing requirements. The client can complete the file sharing operation locally through the regular file sharing task interface.
{% endhint %}
